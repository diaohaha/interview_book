## 分布式ID生成器

```
方法1: 使用UUID算法，UUID由12字节组成

4个字节的unix timestamp 
3个字节的机器ID
2个字节的进程ID
3个字节表示的计数器

优点是天然支持分布式，缺点是id太长，占内存，索引查询效率低

方法2: 号段模式

每次向数据库批量申请一批ID，加载到内存中，当ID分配完的时候再申请一批。

方法3 Twitter的雪花算法

Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。

优点是每个机器有一个库即可，不需要单独搭一个分布式ID服务

```

## 短链服务

```
需求分析：短链能解析回长链

Q:短链的长度多少合适呢？
A:7位 26小写字母+26大写字母+10数字 62的7次方 = 3万亿

Q:如何生成短链
A:分布式ID生成器，自增的每次生成一个短链。使用KV存储, k为短链 v为长链

```


## 秒杀系统

```
需求分析：数据只有一份，千万级的流量访问。

将整个流程分层，浏览器层，站点层，服务层，数据层。将请求尽可能的在上层拦截。

浏览器（app）层：用户点击查询/购买后，按钮置灰，防止无用请求；现在用户的访问频率，比如1秒最多1次
站点（网管）层：uid限流，防刷。
服务层：写请求做请求队列，读请求做缓存
数据层：无感知


```

## 抢红包系统 

```
包红包 - 发红包 - 抢红包 - 拆红包

最复杂的为拆红包 (瞬时流量大，只有部分人能抢到，类似秒杀系统)
```

## 实现一个延时队列

```
量不大的话直接用DB，写上runtime。

1. RabbitMQ 延时队列
RabbitMQ可以设置过期时间，过期后投递到死信队列，消费死信队列执行任务即可。

2. 时间轮
类似手表，存储结构是一个环形数组，每个元素是一个链表，存定时任务。 
时间轮表示的时间有限，如果delay的时间超过时间轮的跨度，需要层级时间轮，如同从秒变成分。

```