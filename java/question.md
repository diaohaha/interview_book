
### Java中的数据类型

```
java中有8中基础数据类型：byte,short,int,long,float,double,char,boolean. 基本数据类型存放在栈上，引用类型在栈上只存放引用地址。其他数据存储在堆上。
```

### java中static、final、static final的区别

```
static 静态（方法 属性 内部类 代码块）

static声明的方法为类方法。不实例化对象就能够调用。所有的对象共用一个static方法和变量。 static方法只能调用其他static方法，只能访问static变量，不能出现this&super。

static修饰类的化，只能修饰内部类（类中类）。 被修饰的内部类可以当作一个普通的类使用。不需要外部类的实例化。


static可以声明静态代码块。jvm加载类的时候会执行。可以在这里对其他static变量赋值。

final 

修饰变量。final的目的是阻止被修改，这也意味着声明的时候必须进行初始化。（类似const） 

修饰方法。被final修饰的方法可以被继承，不能被重载。还有一个原因是高效，Java编译器在遇到final修饰的方法的时候会转入内嵌机制， 提高执行效率。

修饰类。 final修饰的类不能被继承。

两者同时使用。通常用来修饰全局常量。

```

### String和StringBuilder、StringBuffer的区别？

```
String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。

StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。

StringBuilder：StringBuffer 的非线程安全版本，没有使用 synchronized，具有更高的性能，推荐优先使用。
```

### String s = new String("xyz") 创建了几个字符串对象？

```
```

### == 和 equals 的区别是什么？

```
对于基础类型变量。==和equals相同。
对于引用数据类型。 == 比较引用地址。 equals比较值
```

### 什么是反射

```
反射是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。
```

### 深拷贝和浅拷贝区别是什么？

```
数据分为基本数据类型和引用数据类型。基本数据类型：数据直接存储在栈中；引用数据类型：存储在栈中的是对象的引用地址，真实的对象数据存放在堆内存里。

浅拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：只是复制了对象的引用地址，新旧对象指向同一个内存地址，修改其中一个对象的值，另一个对象的值随之改变。

深拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：开辟新的内存空间，在新的内存空间里复制一个一模一样的对象，新老对象不共享内存，修改其中一个对象的值，不会影响另一个对象。

深拷贝相比于浅拷贝速度较慢并且花销较大。
```

### 重载（Overload）和重写（Override）的区别？

```
方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载：一个类中有多个同名的方法，但是具有有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。

重写：发生在子类与父类之间，子类对父类的方法进行重写，参数都不能改变，返回值类型可以不相同，但是必须是父类返回值的派生类。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。
```

### 抽象类（abstract class）和接口（interface）有什么区别？

```
抽象类只能单继承，接口可以多实现。

抽象类可以有构造方法，接口中不能有构造方法。

抽象类中可以有成员变量，接口中没有成员变量，只能有常量（默认就是 public static final）

接口是自上而下的抽象过程，接口规范了某些行为，是对某一行为的抽象。我需要这个行为，我就去实现某个接口，但是具体这个行为怎么实现，完全由自己决定。

抽象类是自下而上的抽象过程，抽象类提供了通用实现，是对某一类事物的抽象。我们在写实现类的时候，发现某些实现类具有几乎相同的实现，因此我们将这些相同的实现抽取出来成为抽象类，然后如果有一些差异点，则可以提供抽象方法来支持自定义实现。
```

### 线程的 join() 方法是干啥用的？

```
用于等待当前线程终止。如果一个线程A执行了 threadB.join() 语句，其含义是：当前线程A等待 threadB 线程终止之后才从 threadB.join() 返回继续往下执行自己的代码。
```

### Thread 调用 start() 方法和调用 run() 方法的区别

```
run()：普通的方法调用，在主线程中执行，不会新建一个线程来执行。

start()：新启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到 CPU 时间片，就开始执行 run() 方法。
```

### JAVA的内存结构

```
程序计数器：线程私有。一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。

Java虚拟机栈：线程私有。它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

本地方法栈：线程私有。本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

Java堆：线程共享。对大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

方法区：与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息（构造方法、接口定义）、常量、静态变量、即时编译器编译后的代码（字节码）等数据。方法区是JVM规范中定义的一个概念，具体放在哪里，不同的实现可以放在不同的地方。

运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
```